Artificial Intelligence | Adversarial Search - Javatpoint?HomeDBMSAIBlockchainHTMLCSSJavaScriptSeleniumDSControl SystemJavaSeleniumjQueryQuizProjectsInterview QCommentForumTrainingAI TutorialAI Tutorial AI Introduction Application of AI History of AI Types of AIIntelligent AgentTypes of Agents Intelligent Agent Agent Environment Turing Test in AIProblem-solvingSearch Algorithms Uninformed Search Algorithm Informed Search Algorithms Hill Climbing Algorithm Means-Ends AnalysisAdversarial SearchAdversarial search Minimax Algorithm Alpha-Beta PruningKnowledge RepresentKnowledge Based Agent Knowledge Representation Knowledge Representation Techniques Propositional Logic Rules of Inference The Wumpus world knowledge-base for Wumpus World First-order logic Knowledge Engineering in FOL Inference in First-Order Logic Unification in FOL Resolution in FOL Forward Chaining and backward chaining Backward Chaining vs Forward Chaining Reasoning in AI Inductive vs. Deductive reasoningUncertain Knowledge R.Probabilistic Reasoning in AI Bayes theorem in AI Bayesian Belief NetworkSubsets of AISubsets of AI Expert Systems Machine Learning Tutorial NLP TutorialRelated TutorialsTensorflow Tutorial PyTorch Tutorial Data Science Tutorial Reinforcement Learningnext ? ? prevAdversarial SearchAdversarial search is a search, where we examine the problem which arises when we try to plan ahead of the world and other agents are planning against us. In previous topics, we have studied the search strategies which are only associated with a single agent that aims to find the solution which often expressed in the form of a sequence of actions.But, there might be some situations where more than one agent is searching for the solution in the same search space, and this situation usually occurs in game playing.The environment with more than one agent is termed as multi-agent environment, in which each agent is an opponent of other agent and playing against each other. Each agent needs to consider the action of other agent and effect of that action on their performance.So, Searches in which two or more players with conflicting goals are trying to explore the same search space for the solution, are called adversarial searches, often known as Games.Games are modeled as a Search problem and heuristic evaluation function, and these are the two main factors which help to model and solve games in AI.Types of Games in AI:DeterministicChance MovesPerfect informationChess, Checkers, go, OthelloBackgammon, monopolyImperfect informationBattleships, blind, tic-tac-toeBridge, poker, scrabble, nuclear warPerfect information: A game with the perfect information is that in which agents can look into the complete board. Agents have all the information about the game, and they can see each other moves also. Examples are Chess, Checkers, Go, etc.Imperfect information: If in a game agents do not have all information about the game and not aware with what's going on, such type of games are called the game with imperfect information, such as tic-tac-toe, Battleship, blind, Bridge, etc.Deterministic games: Deterministic games are those games which follow a strict pattern and set of rules for the games, and there is no randomness associated with them. Examples are chess, Checkers, Go, tic-tac-toe, etc.Non-deterministic games: Non-deterministic are those games which have various unpredictable events and has a factor of chance or luck. This factor of chance or luck is introduced by either dice or cards. These are random, and each action response is not fixed. Such games are also called as stochastic games.Example: Backgammon, Monopoly, Poker, etc.Note: In this topic, we will discuss deterministic games, fully observable environment, zero-sum, and where each agent acts alternatively.Zero-Sum GameZero-sum games are adversarial search which involves pure competition.In Zero-sum game each agent's gain or loss of utility is exactly balanced by the losses or gains of utility of another agent.One player of the game try to maximize one single value, while other player tries to minimize it.Each move by one player in the game is called as ply.Chess and tic-tac-toe are examples of a Zero-sum game.Zero-sum game: Embedded thinkingThe Zero-sum game involved embedded thinking in which one agent or player is trying to figure out:What to do.How to decide the moveNeeds to think about his opponent as wellThe opponent also thinks what to doEach of the players is trying to find out the response of his opponent to their actions. This requires embedded thinking or backward reasoning to solve the game problems in AI.Formalization of the problem:A game can be defined as a type of search in AI which can be formalized of the following elements:Initial state: It specifies how the game is set up at the start.Player(s): It specifies which player has moved in the state space.Action(s): It returns the set of legal moves in state space.Result(s, a): It is the transition model, which specifies the result of moves in the state space.Terminal-Test(s): Terminal test is true if the game is over, else it is false at any case. The state where the game ends is called terminal states.Utility(s, p): A utility function gives the final numeric value for a game that ends in terminal states s for player p. It is also called payoff function. For Chess, the outcomes are a win, loss, or draw and its payoff values are +1, 0, ½. And for tic-tac-toe, utility values are +1, -1, and 0.Game tree:A game tree is a tree where nodes of the tree are the game states and Edges of the tree are the moves by players. Game tree involves initial state, actions function, and result Function.Example: Tic-Tac-Toe game tree:The following figure is showing part of the game-tree for tic-tac-toe game. Following are some key points of the game:There are two players MAX and MIN.Players have an alternate turn and start with MAX.MAX maximizes the result of the game treeMIN minimizes the result.Example Explanation:From the initial state, MAX has 9 possible moves as he starts first. MAX place x and MIN place o, and both player plays alternatively until we reach a leaf node where one player has three in a row or all squares are filled.Both players will compute each node, minimax, the minimax value which is the best achievable utility against an optimal adversary.Suppose both the players are well aware of the tic-tac-toe and playing the best play. Each player is doing his best to prevent another one from winning. MIN is acting against Max in the game.So in the game tree, we have a layer of Max, a layer of MIN, and each layer is called as Ply. Max place x, then MIN puts o to prevent Max from winning, and this game continues until the terminal node.In this either MIN wins, MAX wins, or it's a draw. This game-tree is the whole search space of possibilities that MIN and MAX are playing tic-tac-toe and taking turns alternately.Hence adversarial Search for the minimax procedure works as follows:It aims to find the optimal strategy for MAX to win the game.It follows the approach of Depth-first search.In the game tree, optimal leaf node could appear at any depth of the tree.Propagate the minimax values up to the tree until the terminal node discovered.In a given game tree, the optimal strategy can be determined from the minimax value of each node, which can be written as MINIMAX(n). MAX prefer to move to a state of maximum value and MIN prefer to move to a state of minimum value then:Next TopicMini-Max Algorithm? prev next ?Help Others, Please ShareLearn Latest TutorialsOpenpyxlTallyGodotSpring BootGradleUMLANNES6FlutterSelenium PyFirebaseCobolPreparationAptitudeReasoningVerbal A.InterviewCompanyTrending TechnologiesAIAWSSeleniumCloudHadoopReactJSD. ScienceAngular 7BlockchainGitMLDevOpsB.Tech / MCADBMSDSDAAOSC. NetworkCompiler D.COAD. Math.E. HackingC. GraphicsSoftware E.Web Tech.Cyber Sec.AutomataCC++Java.NetPythonProgramsControl S.Data MiningJavatpoint ServicesJavaTpoint offers too many high quality services. Mail us on hr@javatpoint.com, to get more information about given services.Website DesigningWebsite DevelopmentJava DevelopmentPHP DevelopmentWordPressGraphic DesigningLogoDigital MarketingOn Page and Off Page SEOPPCContent DevelopmentCorporate TrainingClassroom and Online TrainingData EntryTraining For College CampusJavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at hr@javatpoint.com.Duration: 1 week to 2 weekLike/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring TutorialOur WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.comOur ServicesWebsite DevelopmentAndroid DevelopmentWebsite DesigningDigital MarketingSummer TrainingIndustrial TrainingCollege Campus TrainingContactAddress: G-13, 2nd Floor, Sec-3Noida, UP, 201301, IndiaContact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemapAbout Me© Copyright 2011-2018 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.