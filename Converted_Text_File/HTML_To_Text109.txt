Uninformed Search Algorithms - Javatpoint?HomeDBMSAIBlockchainHTMLCSSJavaScriptSeleniumDSControl SystemJavaSeleniumjQueryQuizProjectsInterview QCommentForumTrainingAI TutorialAI Tutorial AI Introduction Application of AI History of AI Types of AIIntelligent AgentTypes of Agents Intelligent Agent Agent Environment Turing Test in AIProblem-solvingSearch Algorithms Uninformed Search Algorithm Informed Search Algorithms Hill Climbing Algorithm Means-Ends AnalysisAdversarial SearchAdversarial search Minimax Algorithm Alpha-Beta PruningKnowledge RepresentKnowledge Based Agent Knowledge Representation Knowledge Representation Techniques Propositional Logic Rules of Inference The Wumpus world knowledge-base for Wumpus World First-order logic Knowledge Engineering in FOL Inference in First-Order Logic Unification in FOL Resolution in FOL Forward Chaining and backward chaining Backward Chaining vs Forward Chaining Reasoning in AI Inductive vs. Deductive reasoningUncertain Knowledge R.Probabilistic Reasoning in AI Bayes theorem in AI Bayesian Belief NetworkSubsets of AISubsets of AI Expert Systems Machine Learning Tutorial NLP TutorialRelated TutorialsTensorflow Tutorial PyTorch Tutorial Data Science Tutorial Reinforcement Learningnext ? ? prevUninformed Search AlgorithmsUninformed search is a class of general-purpose search algorithms which operates in brute force-way. Uninformed search algorithms do not have additional information about state or search space other than how to traverse the tree, so it is also called blind search.Following are the various types of uninformed search algorithms:Breadth-first SearchDepth-first Search Depth-limited SearchIterative deepening depth-first searchUniform cost searchBidirectional Search1. Breadth-first Search:Breadth-first search is the most common search strategy for traversing a tree or graph. This algorithm searches breadthwise in a tree or graph, so it is called breadth-first search.BFS algorithm starts searching from the root node of the tree and expands all successor node at the current level before moving to nodes of next level.The breadth-first search algorithm is an example of a general-graph search algorithm.Breadth-first search implemented using FIFO queue data structure.Advantages:BFS will provide a solution if any solution exists.If there are more than one solutions for a given problem, then BFS will provide the minimal solution which requires the least number of steps.Disadvantages:It requires lots of memory since each level of the tree must be saved into memory to expand the next level.BFS needs lots of time if the solution is far away from the root node.Example:In the below tree structure, we have shown the traversing of the tree using BFS algorithm from the root node S to goal node K. BFS search algorithm traverse in layers, so it will follow the path which is shown by the dotted arrow, and the traversed path will be:S---> A--->B---->C--->D---->G--->H--->E---->F---->I---->KTime Complexity: Time Complexity of BFS algorithm can be obtained by the number of nodes traversed in BFS until the shallowest Node. Where the d= depth of shallowest solution and b is a node at every state.T (b) = 1+b2+b3+.......+ bd= O (bd)Space Complexity: Space complexity of BFS algorithm is given by the Memory size of frontier which is O(bd).Completeness: BFS is complete, which means if the shallowest goal node is at some finite depth, then BFS will find a solution.Optimality: BFS is optimal if path cost is a non-decreasing function of the depth of the node.2. Depth-first SearchDepth-first search isa recursive algorithm for traversing a tree or graph data structure.It is called the depth-first search because it starts from the root node and follows each path to its greatest depth node before moving to the next path.DFS uses a stack data structure for its implementation.The process of the DFS algorithm is similar to the BFS algorithm.Note: Backtracking is an algorithm technique for finding all possible solutions using recursion.Advantage:DFS requires very less memory as it only needs to store a stack of the nodes on the path from root node to the current node.It takes less time to reach to the goal node than BFS algorithm (if it traverses in the right path).Disadvantage: There is the possibility that many states keep re-occurring, and there is no guarantee of finding the solution.DFS algorithm goes for deep down searching and sometime it may go to the infinite loop.Example:In the below search tree, we have shown the flow of depth-first search, and it will follow the order as:Root node--->Left node ----> right node.It will start searching from root node S, and traverse A, then B, then D and E, after traversing E, it will backtrack the tree as E has no other successor and still goal node is not found. After backtracking it will traverse node C and then G, and here it will terminate as it found goal node.Completeness: DFS search algorithm is complete within finite state space as it will expand every node within a limited search tree.Time Complexity: Time complexity of DFS will be equivalent to the node traversed by the algorithm. It is given by:T(n)= 1+ n2+ n3 +.........+ nm=O(nm)Where, m= maximum depth of any node and this can be much larger than d (Shallowest solution depth)Space Complexity: DFS algorithm needs to store only single path from the root node, hence space complexity of DFS is equivalent to the size of the fringe set, which is O(bm).Optimal: DFS search algorithm is non-optimal, as it may generate a large number of steps or high cost to reach to the goal node.3. Depth-Limited Search Algorithm:A depth-limited search algorithm is similar to depth-first search with a predetermined limit. Depth-limited search can solve the drawback of the infinite path in the Depth-first search. In this algorithm, the node at the depth limit will treat as it has no successor nodes further.Depth-limited search can be terminated with two Conditions of failure:Standard failure value: It indicates that problem does not have any solution.Cutoff failure value: It defines no solution for the problem within a given depth limit.Advantages:Depth-limited search is Memory efficient.Disadvantages:Depth-limited search also has a disadvantage of incompleteness.It may not be optimal if the problem has more than one solution.Example:Completeness: DLS search algorithm is complete if the solution is above the depth-limit.Time Complexity: Time complexity of DLS algorithm is O(b?).Space Complexity: Space complexity of DLS algorithm is O(b×?).Optimal: Depth-limited search can be viewed as a special case of DFS, and it is also not optimal even if ?>d.4. Uniform-cost Search Algorithm:Uniform-cost search is a searching algorithm used for traversing a weighted tree or graph. This algorithm comes into play when a different cost is available for each edge. The primary goal of the uniform-cost search is to find a path to the goal node which has the lowest cumulative cost. Uniform-cost search expands nodes according to their path costs form the root node. It can be used to solve any graph/tree where the optimal cost is in demand. A uniform-cost search algorithm is implemented by the priority queue. It gives maximum priority to the lowest cumulative cost. Uniform cost search is equivalent to BFS algorithm if the path cost of all edges is the same.Advantages:Uniform cost search is optimal because at every state the path with the least cost is chosen.Disadvantages:It does not care about the number of steps involve in searching and only concerned about path cost. Due to which this algorithm may be stuck in an infinite loop.Example:Completeness:Uniform-cost search is complete, such as if there is a solution, UCS will find it.Time Complexity:Let C* is Cost of the optimal solution, and ? is each step to get closer to the goal node. Then the number of steps is = C*/?+1. Here we have taken +1, as we start from state 0 and end to C*/?.Hence, the worst-case time complexity of Uniform-cost search isO(b1 + [C*/?])/.Space Complexity:The same logic is for space complexity so, the worst-case space complexity of Uniform-cost search is O(b1 + [C*/?]).Optimal:Uniform-cost search is always optimal as it only selects a path with the lowest path cost.5. Iterative deepeningdepth-first Search:The iterative deepening algorithm is a combination of DFS and BFS algorithms. This search algorithm finds out the best depth limit and does it by gradually increasing the limit until a goal is found.This algorithm performs depth-first search up to a certain "depth limit", and it keeps increasing the depth limit after each iteration until the goal node is found.This Search algorithm combines the benefits of Breadth-first search's fast search and depth-first search's memory efficiency.The iterative search algorithm is useful uninformed search when search space is large, and depth of goal node is unknown.Advantages:Itcombines the benefits of BFS and DFS search algorithm in terms of fast search and memory efficiency.Disadvantages:The main drawback of IDDFS is that it repeats all the work of the previous phase.Example:Following tree structure is showing the iterative deepening depth-first search. IDDFS algorithm performs various iterations until it does not find the goal node. The iteration performed by the algorithm is given as:1'st Iteration-----> A2'nd Iteration----> A, B, C3'rd Iteration------>A, B, D, E, C, F, G4'th Iteration------>A, B, D, H, I, E, C, F, K, GIn the fourth iteration, the algorithm will find the goal node.Completeness:This algorithm is complete is ifthe branching factor is finite.Time Complexity:Let's suppose b is the branching factor and depth is d then the worst-case time complexity is O(bd).Space Complexity:The space complexity of IDDFS will be O(bd).Optimal:IDDFS algorithm is optimal if path cost is a non- decreasing function of the depth of the node.6. Bidirectional Search Algorithm:Bidirectional search algorithm runs two simultaneous searches, one form initial state called as forward-search and other from goal node called as backward-search, to find the goal node. Bidirectional search replaces one single search graph with two small subgraphs in which one starts the search from an initial vertex and other starts from goal vertex. The search stops when these two graphs intersect each other.Bidirectional search can use search techniques such as BFS, DFS, DLS, etc.Advantages:Bidirectional search is fast.Bidirectional search requires less memoryDisadvantages:Implementation of the bidirectional search tree is difficult.In bidirectional search, one should know the goal state in advance.Example:In the below search tree, bidirectional search algorithm is applied. This algorithm divides one graph/tree into two sub-graphs. It starts traversing from node 1 in the forward direction and starts from goal node 16 in the backward direction.The algorithm terminates at node 9 where two searches meet.Completeness: Bidirectional Search is complete if we use BFS in both searches.Time Complexity: Time complexity of bidirectional search using BFS is O(bd).Space Complexity: Space complexity of bidirectional search is O(bd).Optimal: Bidirectional search is Optimal.Next TopicInformed Search Algorithms in AI? prev next ?Help Others, Please ShareLearn Latest TutorialsOpenpyxlTallyGodotSpring BootGradleUMLANNES6FlutterSelenium PyFirebaseCobolPreparationAptitudeReasoningVerbal A.InterviewCompanyTrending TechnologiesAIAWSSeleniumCloudHadoopReactJSD. ScienceAngular 7BlockchainGitMLDevOpsB.Tech / MCADBMSDSDAAOSC. NetworkCompiler D.COAD. Math.E. HackingC. GraphicsSoftware E.Web Tech.Cyber Sec.AutomataCC++Java.NetPythonProgramsControl S.Data MiningJavatpoint ServicesJavaTpoint offers too many high quality services. Mail us on hr@javatpoint.com, to get more information about given services.Website DesigningWebsite DevelopmentJava DevelopmentPHP DevelopmentWordPressGraphic DesigningLogoDigital MarketingOn Page and Off Page SEOPPCContent DevelopmentCorporate TrainingClassroom and Online TrainingData EntryTraining For College CampusJavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at hr@javatpoint.com.Duration: 1 week to 2 weekLike/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring TutorialOur WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.comOur ServicesWebsite DevelopmentAndroid DevelopmentWebsite DesigningDigital MarketingSummer TrainingIndustrial TrainingCollege Campus TrainingContactAddress: G-13, 2nd Floor, Sec-3Noida, UP, 201301, IndiaContact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemapAbout Me© Copyright 2011-2018 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.