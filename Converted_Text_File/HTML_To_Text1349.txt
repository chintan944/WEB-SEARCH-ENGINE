Software Engineering | COCOMO Model - javatpoint?HomeSoftware TestingSoftware EngineeringCompilerJavaCOAComputer NetworkHTMLCSSSeleniumServletJSPjQueryQuizProjectsInterview QCommentForumTrainingSoftware EngineeringTutorial Software Processes SDLC SDLC Models Requirement EngineeringModelsWaterfall Model RAD Model Spiral Model V-model Incremental Model Agile Model Iterative Model Big-Bang Model Prototype ModelSoftware ManagementProject Management Activities Project Management ToolsSoftware MetricsSoftware Metrics Size Oriented Metrics Halstead's Software Metrics Functional Point (FP) Analysis Extended Function Point (EFP) Metrics Data Structure Metrics Information Flow Metrics Cyclomatic Complexity Case Tools For Software MetricsProject PlanningSoftware Project Planning Software Cost Estimation COCOMO Model Putnam Resource Allocation ModelRisk ManagementRisk Management Risk Management Activities Project Scheduling Personnel PlanningSoftware RequirementSoftware Requirement Specifications Requirements Analysis Data Flow Diagrams Data Dictionaries Entity-Relationship DiagramS/W ConfigurationSoftware Configuration Management SCM Process Software Quality Assurance Project Monitoring & ControlSoftware QualitySoftware Quality ISO 9000 Certification SEICMM PCMM Six SigmaSoftware DesignSoftware Design Software Design Principles Coupling and Cohesion Function Oriented Design Object Oriented Design User Interface DesignCodingCoding Programming Style Structured ProgrammingSoftware ReliabilitySoftware Reliability Software Failure Mechanisms Software Reliability Measurement Techniques Software Reliability Metrics Software Fault ToleranceS. Reliability ModelsSoftware Reliability Models Jelinski & Moranda Model Basic Execution Time Model Goel-Okumoto (GO) Model Musa-Okumoto Logarithmic ModelSoftware MaintenanceSoftware Maintenance Causes of Software Maintenance Problems Software Maintenance Cost FactorsSoftware TestingSoftware Testing Tutorialnext ? ? prevCOCOMO ModelBoehm proposed COCOMO (Constructive Cost Estimation Model) in 1981.COCOMO is one of the most generally used software estimation models in the world. COCOMO predicts the efforts and schedule of a software product based on the size of the software.The necessary steps in this model are:Get an initial estimate of the development effort from evaluation of thousands of delivered lines of source code (KDLOC).Determine a set of 15 multiplying factors from various attributes of the project.Calculate the effort estimate by multiplying the initial estimate with all the multiplying factors i.e., multiply the values in step1 and step2.The initial estimate (also called nominal estimate) is determined by an equation of the form used in the static single variable models, using KDLOC as the measure of the size. To determine the initial effort Ei in person-months the equation used is of the type is shown below                Ei=a*(KDLOC)bThe value of the constant a and b are depends on the project type.In COCOMO, projects are categorized into three types:OrganicSemidetachedEmbedded1.Organic: A development project can be treated of the organic type, if the project deals with developing a well-understood application program, the size of the development team is reasonably small, and the team members are experienced in developing similar methods of projects. Examples of this type of projects are simple business systems, simple inventory management systems, and data processing systems.2. Semidetached: A development project can be treated with semidetached type if the development consists of a mixture of experienced and inexperienced staff. Team members may have finite experience in related systems but may be unfamiliar with some aspects of the order being developed. Example of Semidetached system includes developing a new operating system (OS), a Database Management System (DBMS), and complex inventory management system.3. Embedded: A development project is treated to be of an embedded type, if the software being developed is strongly coupled to complex hardware, or if the stringent regulations on the operational method exist. For Example: ATM, Air Traffic control.For three product categories, Bohem provides a different set of expression to predict effort (in a unit of person month)and development time from the size of estimation in KLOC(Kilo Line of code) efforts estimation takes into account the productivity loss due to holidays, weekly off, coffee breaks, etc.According to Boehm, software cost estimation should be done through three stages:Basic ModelIntermediate ModelDetailed Model1. Basic COCOMO Model: The basic COCOMO model provide an accurate size of the project parameters. The following expressions give the basic COCOMO estimation model:                Effort=a1*(KLOC) a2 PM                Tdev=b1*(efforts)b2 MonthsWhereKLOC is the estimated size of the software product indicate in Kilo Lines of Code,a1,a2,b1,b2 are constants for each group of software products,Tdev is the estimated time to develop the software, expressed in months,Effort is the total effort required to develop the software product, expressed in person months (PMs).Estimation of development effort For the three classes of software products, the formulas for estimating the effort based on the code size are shown below:Organic: Effort = 2.4(KLOC) 1.05 PMSemi-detached: Effort = 3.0(KLOC) 1.12 PMEmbedded: Effort = 3.6(KLOC) 1.20 PMEstimation of development time For the three classes of software products, the formulas for estimating the development time based on the effort are given below:Organic: Tdev = 2.5(Effort) 0.38 MonthsSemi-detached: Tdev = 2.5(Effort) 0.35 MonthsEmbedded: Tdev = 2.5(Effort) 0.32 MonthsSome insight into the basic COCOMO model can be obtained by plotting the estimated characteristics for different software sizes. Fig shows a plot of estimated effort versus product size. From fig, we can observe that the effort is somewhat superliner in the size of the software product. Thus, the effort required to develop a product increases very rapidly with project size.The development time versus the product size in KLOC is plotted in fig. From fig it can be observed that the development time is a sub linear function of the size of the product, i.e. when the size of the product increases by two times, the time to develop the product does not double but rises moderately. This can be explained by the fact that for larger products, a larger number of activities which can be carried out concurrently can be identified. The parallel activities can be carried out simultaneously by the engineers. This reduces the time to complete the project. Further, from fig, it can be observed that the development time is roughly the same for all three categories of products. For example, a 60 KLOC program can be developed in approximately 18 months, regardless of whether it is of organic, semidetached, or embedded type.From the effort estimation, the project cost can be obtained by multiplying the required effort by the manpower cost per month. But, implicit in this project cost computation is the assumption that the entire project cost is incurred on account of the manpower cost alone. In addition to manpower cost, a project would incur costs due to hardware and software required for the project and the company overheads for administration, office space, etc.It is important to note that the effort and the duration estimations obtained using the COCOMO model are called a nominal effort estimate and nominal duration estimate. The term nominal implies that if anyone tries to complete the project in a time shorter than the estimated duration, then the cost will increase drastically. But, if anyone completes the project over a longer period of time than the estimated, then there is almost no decrease in the estimated cost value.Example1: Suppose a project was estimated to be 400 KLOC. Calculate the effort and development time for each of the three model i.e., organic, semi-detached & embedded.Solution: The basic COCOMO equation takes the form:                Effort=a1*(KLOC) a2 PM                Tdev=b1*(efforts)b2 Months                Estimated Size of project= 400 KLOC(i)Organic Mode                E = 2.4 * (400)1.05 = 1295.31 PM                D = 2.5 * (1295.31)0.38=38.07 PM(ii)Semidetached Mode                E = 3.0 * (400)1.12=2462.79 PM                D = 2.5 * (2462.79)0.35=38.45 PM(iii) Embedded Mode                E = 3.6 * (400)1.20 = 4772.81 PM                D = 2.5 * (4772.8)0.32 = 38 PMExample2: A project size of 200 KLOC is to be developed. Software development team has average experience on similar type of projects. The project schedule is not very tight. Calculate the Effort, development time, average staff size, and productivity of the project.Solution: The semidetached mode is the most appropriate mode, keeping in view the size, schedule and experience of development time.Hence       E=3.0(200)1.12=1133.12PM                D=2.5(1133.12)0.35=29.3PM            P = 176 LOC/PM2. Intermediate Model: The basic Cocomo model considers that the effort is only a function of the number of lines of code and some constants calculated according to the various software systems. The intermediate COCOMO model recognizes these facts and refines the initial estimates obtained through the basic COCOMO model by using a set of 15 cost drivers based on various attributes of software engineering.Classification of Cost Drivers and their attributes:(i) Product attributes -Required software reliability extentSize of the application databaseThe complexity of the productHardware attributes -Run-time performance constraintsMemory constraintsThe volatility of the virtual machine environmentRequired turnabout timePersonnel attributes -Analyst capabilitySoftware engineering capabilityApplications experienceVirtual machine experienceProgramming language experienceProject attributes -Use of software toolsApplication of software engineering methodsRequired development scheduleThe cost drivers are divided into four categories:Intermediate COCOMO equation:                E=ai (KLOC) bi*EAF                D=ci (E)diCoefficients for intermediate COCOMOProjectaibicidiOrganic2.41.052.50.38Semidetached3.01.122.50.35Embedded3.61.202.50.323. Detailed COCOMO Model:Detailed COCOMO incorporates all qualities of the standard version with an assessment of the cost driver?s effect on each method of the software engineering process. The detailed model uses various effort multipliers for each cost driver property. In detailed cocomo, the whole software is differentiated into multiple modules, and then we apply COCOMO in various modules to estimate effort and then sum the effort.The Six phases of detailed COCOMO are:Planning and requirementsSystem structureComplete structureModule code and testIntegration and testCost Constructive modelThe effort is determined as a function of program estimate, and a set of cost drivers are given according to every phase of the software lifecycle.Next TopicPutnam Resource Allocation Model? prev next ?Help Others, Please ShareLearn Latest TutorialsOpenpyxlTallyGodotSpring BootGradleUMLANNES6FlutterSelenium PyFirebaseCobolPreparationAptitudeReasoningVerbal A.InterviewCompanyTrending TechnologiesAIAWSSeleniumCloudHadoopReactJSD. ScienceAngular 7BlockchainGitMLDevOpsB.Tech / MCADBMSDSDAAOSC. NetworkCompiler D.COAD. Math.E. HackingC. GraphicsSoftware E.Web Tech.Cyber Sec.AutomataCC++Java.NetPythonProgramsControl S.Data MiningJavatpoint ServicesJavaTpoint offers too many high quality services. Mail us on hr@javatpoint.com, to get more information about given services.Website DesigningWebsite DevelopmentJava DevelopmentPHP DevelopmentWordPressGraphic DesigningLogoDigital MarketingOn Page and Off Page SEOPPCContent DevelopmentCorporate TrainingClassroom and Online TrainingData EntryTraining For College CampusJavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at hr@javatpoint.com.Duration: 1 week to 2 weekLike/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring TutorialOur WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.comOur ServicesWebsite DevelopmentAndroid DevelopmentWebsite DesigningDigital MarketingSummer TrainingIndustrial TrainingCollege Campus TrainingContactAddress: G-13, 2nd Floor, Sec-3Noida, UP, 201301, IndiaContact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemapAbout Me© Copyright 2011-2018 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.