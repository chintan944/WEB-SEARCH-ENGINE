Activity or Task Scheduling Problem - javatpoint?HomeDSDAADBMSAptitudeSeleniumKotlinC#HTMLCSSJavaScriptjQueryQuizProjectsInterview QCommentForumTrainingDAA TutorialDAA Tutorial DAA Algorithm Need of Algorithm Complexity of Algorithm Algorithm Design TechniquesAsymptotic AnalysisAsymptotic Analysis Analyzing Algorithm Control StructureRecurrenceRecurrence Relation Recursion Tree Method Master MethodAnalysis of SortingBubble Sort Selection Sort Insertion SortDivide and ConquerIntroduction Max-Min Problem Binary Search Merge Sort Tower of HanoiSortingBinary Heap Quick Sort Stable SortingLower bound Theory Lower bound Theory Sorting in Linear TimeLinear Time Counting Sort Bucket Sort Radix SortHashingHashing Hash Tables Hashing Method Open Addressing Techniques Hash FunctionBinary Search TreesBinary SearchRed Black TreeRed BlackDynamic ProgrammingIntroduction Divide & Conquer Method vs Dynamic Programming Fibonacci sequence Matrix Chain Multiplication Matrix Chain Multiplication Example Matrix Chain Multiplication Algorithm Longest Common Sequence Longest Common Sequence Algorithm 0/1 Knapsack ProblemGreedy AlgorithmIntroduction Activity Selection Problem Fractional Knapsack problem Huffman Codes Algorithm of Huffman Code Activity or Task Scheduling Problem Travelling Sales Person Problem Dynamic Programming vs Greedy MethodBacktrackingBacktracking Introduction Recursive Maze Algorithm Hamiltonian Circuit Problems Subset Sum Problems N Queens ProblemsMSTMST Introduction MST Applications Kruskal's Algorithm Prim's AlgorithmShortest PathIntroduction Negative Weight Edges Representing Shortest Path Relaxation Dijkstra's Algorithm Bellman-Ford Algorithm Single Source Shortest Path in a directed Acyclic GraphsAll-Pairs Shortest PathsIntroduction Floyd-Warshall Algorithm Johnson's AlgorithmMaximum FlowFlow networks and Flows Network Flow Problems Ford Fulkerson Algorithm Maximum bipartite matchingSorting NetworksComparison Network Bitonic Sorting Network Merging NetworkComplexity TheoryComplexity Classes Polynomial Time Verification NP-Completeness Circuit Satisfiability 3-CNF Satisfiability Clique Problem Vertex Cover Problem Subset-Sum ProblemApproximation AlgoIntroduction Vertex Cover Travelling Salesman ProblemString MatchingIntroduction Naive String Matching Algorithm Rabin-Karp-Algorithm String Matching with Finite Automata Knuth-Morris-Pratt Algorithm Boyer-Moore AlgorithmInterview QuestionsDAA Interview Questionsnext ? ? prevActivity or Task Scheduling ProblemThis is the dispute of optimally scheduling unit-time tasks on a single processor, where each job has a deadline and a penalty that necessary be paid if the deadline is missed.A unit-time task is a job, such as a program to be rush on a computer that needed precisely one unit of time to complete. Given a finite set S of unit-time tasks, a schedule for S is a permutation of S specifying the order in which to perform these tasks. The first task in the schedule starts at time 0 and ends at time 1; the second task begins at time 1 and finishes at time 2, and so on.The dispute of scheduling unit-time tasks with deadlines and penalties for each processor has the following inputs:a set S = {1, 2, 3.....n} of n unit-time tasks.a set of n integer deadlines d1 d2 d3...dn such that di satisfies 1? di ? n and task i is supposed to finish by time di anda set of n non-negative weights or penalties w1 w2....wn such that we incur a penalty of wi if task i is not finished by time di, and we incurred no penalty if a task finishes by its deadline.Here we find a schedule for S that minimizes the total penalty incurred for missed deadlines.A task is late in this schedule if it finished after its deadline. Otherwise, the task is early in the schedule. An arbitrary schedule can consistently be put into early-first form, in which the first tasks precede the late tasks, i.e., if some new task x follows some late task y, then we can switch the position of x and y without affecting x being early or y being late.An arbitrary schedule can always be put into a canonical form in which first tasks precede the late tasks, and first tasks are scheduled in order of nondecreasing deadlines.A set A of tasks is independent if there exists a schedule for the particular tasks such that no tasks are late. So the set of first tasks for a schedule forms an independent set of tasks 'l' denote the set of all independent set of tasks.For any set of tasks A, A is independent if for t = 0, 1, 2.....n we have Nt(A) ? t where Nt(A) denotes the number of tasks in A whose deadline is t or prior, i.e. if the tasks in A are expected in order of monotonically growing deadlines, then no task is late.Example: Find the optimal schedule for the following task with given weight (penalties) and deadlines.1234567di4243146wi70605040302010Solution: According to the Greedy algorithm we sort the jobs in decreasing order of their penalties so that minimum of penalties will be charged.In this problem, we can see that the maximum time for which uniprocessor machine will run in 6 units because it is the maximum deadline.Let Ti represents the tasks where i = 1 to 7T5 and T6 cannot be accepted after T7 so penalty isw5 + w6 = 30 + 20 = 50 (2 3 4 1 7 5 6)Other schedule is(2 4 1 3 7 5 6)There can be many other schedules but (2 4 1 3 7 5 6) is optimal.Next TopicTravelling Sales Person Problem? prev next ?Help Others, Please ShareLearn Latest TutorialsOpenpyxlTallyGodotSpring BootGradleUMLANNES6FlutterSelenium PyFirebaseCobolPreparationAptitudeReasoningVerbal A.InterviewCompanyTrending TechnologiesAIAWSSeleniumCloudHadoopReactJSD. ScienceAngular 7BlockchainGitMLDevOpsB.Tech / MCADBMSDSDAAOSC. NetworkCompiler D.COAD. Math.E. HackingC. GraphicsSoftware E.Web Tech.Cyber Sec.AutomataCC++Java.NetPythonProgramsControl S.Data MiningJavatpoint ServicesJavaTpoint offers too many high quality services. Mail us on hr@javatpoint.com, to get more information about given services.Website DesigningWebsite DevelopmentJava DevelopmentPHP DevelopmentWordPressGraphic DesigningLogoDigital MarketingOn Page and Off Page SEOPPCContent DevelopmentCorporate TrainingClassroom and Online TrainingData EntryTraining For College CampusJavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at hr@javatpoint.com.Duration: 1 week to 2 weekLike/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring TutorialOur WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.comOur ServicesWebsite DevelopmentAndroid DevelopmentWebsite DesigningDigital MarketingSummer TrainingIndustrial TrainingCollege Campus TrainingContactAddress: G-13, 2nd Floor, Sec-3Noida, UP, 201301, IndiaContact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemapAbout Me© Copyright 2011-2018 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.